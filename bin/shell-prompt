#!/usr/bin/env perl
use strict;
use warnings;
use File::Basename;
use File::pushd ();

$| = 1;

chomp(my $cols = `tput cols`);

sub in_git_repo {
    my $pwd = $ENV{PWD};

    while ($pwd ne dirname $pwd) {
        return undef if basename($pwd) eq '.git';
        return undef if -l $pwd;
        return $pwd if -d "$pwd/.git";
        $pwd = dirname $pwd;
    }

    return undef;
}

# VCS info
my $vcs = '';
if (my $pwd = in_git_repo) {
    my $pushd_guard = File::pushd::pushd($pwd);
    local $ENV{GIT_DIR} = "$pwd/.git";
    chomp(my @status = `git status --porcelain | awk '{print \$2}'`);
    my %status = map { $_ => 1 } grep $_, @status;

    chomp(my @submodules = `git submodule status | awk '{print \$2}'`);
    my %submodules = map { $_ => 1 } grep $_, @submodules;

    foreach my $submodule (keys %submodules) {
        my $re = qr{^\Q$submodule\E}o;
        foreach my $key (keys %status) {
            delete $status{$key}
                if $key =~ $re;
        }
    }

    #$vcs .= '-' if scalar(keys %status);
    if ( scalar keys %status) {
        $vcs .= "\%{\e[0;31m\%}"; #red
    }
    else {
        $vcs .= "\%{\e[0;33m\%}"; #yellow
    }

    chomp(my $branch = qx!git branch | awk '/^\\*/{print \$2}'!);
    $branch = 'M' if $branch eq 'master';

    if (length($branch) > 12) {
        substr($branch, 0, -6) = '...';
    }

    $vcs .= $branch if $branch;
    $vcs =~ s/\*:/*/;
}

my $output = q{};
if (@ARGV) {
    # show vcs stuff in separate call, for RPS1/RPROMPT/etc
    $output .= "\%{\e[1;30m\%}<$vcs\%{\e[1;30m\%}>\%{\e[m\%}" if $vcs;
}
else {
    $output .= "\%{\e[1;30m\%}[ \%{\e[0;32m\%}\%n\%{\e[m\%}\@\%{\e[0;32m\%}\%m\%{\e[1;30m\%} ->";

    $output .= "\%{\e[1;30m\%} \%{\e[36m\%}\%~\%{\e[30m\%} ]";

    $output .= "\%{\e[m\%} \$ ";
}

print $output;

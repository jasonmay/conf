#!/usr/bin/env perl
use strict;
use warnings;
use File::Basename;

$| = 1;

chomp(my $cols = `tput cols`);

sub in_git_repo {
    my $pwd = $ENV{PWD};

    while ($pwd ne dirname $pwd) {
        return 0 if basename($pwd) eq '.git';
        return 0 if -l $pwd;
        return 1 if -d "$pwd/.git";
        $pwd = dirname $pwd;
    }

    return 0;
}

# VCS info
my $vcs = '';
if (in_git_repo) {
    chomp(my @status = `git status --porcelain | awk '{print \$2}'`);
    my %status = map { $_ => 1 } grep $_, @status;

    chomp(my @submodules = `git submodule status | awk '{print \$2}'`);
    my %submodules = map { $_ => 1 } grep $_, @submodules;

    foreach my $submodule (keys %submodules) {
        my $re = qr{^\Q$submodule\E}o;
        foreach my $key (keys %status) {
            delete $status{$key}
                if $key =~ $re;
        }
    }

    $vcs .= '-' if scalar(keys %status);

    chomp(my $branch = qx!git branch | awk '/^\\*/{print \$2}'!);
    $vcs .= $branch if $branch;
    $vcs =~ s/\*:/*/;
}

my $output = q{};
if (@ARGV) {
    # show vcs stuff in separate call, for RPS1/RPROMPT/etc
    $output .= "\%{\e[1;30m\%}<\%{\e[0;33m\%}$vcs\%{\e[1;30m\%}>\%{\e[m\%}" if $vcs;
}
else {
    $output .= "\%{\e[1;30m\%}[ \%{\e[0;32m\%}\%n\%{\e[m\%}\@\%{\e[0;32m\%}\%m\%{\e[1;30m\%} ->";

    $output .= "\%{\e[1;30m\%} \%{\e[36m\%}\%~\%{\e[30m\%} ]";

    $output .= "\%{\e[m\%} \$ ";
}

print $output;

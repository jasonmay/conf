set encoding=utf8
syntax on
set ruler
set rulerformat=%40(%=%t%h%m%r%w%<\ (%n)\ %4.7l,%-7.(%c%V%)\ %P%)
set showmode
set showcmd
set shortmess=aotTWI
set laststatus=0
set display+=lastline,uhex
set scrolloff=3
set lazyredraw
set hlsearch
set showmatch
set matchtime=2
set report=0
set nomore
set autoread 
set ttyfast
set completeopt=menuone
set incsearch
set tildeop
set backspace=indent,eol,start
set wildmenu
set wildignore+=.log,.out,.o
set viminfo=!,'1000,f1,/1000,:1000,<1000,@1000,h,n~/.viminfo
set isfname+=:
set wildmode=longest,list,full
set hidden
set vb t_vb=
set ttimeoutlen=5
set tabstop=4
set shiftwidth=4
set softtabstop=4
set expandtab
set shiftround
set autoindent
set smartindent
set foldmethod=marker

if hostname() == 'jobs01'
    set bg=dark
else
    set bg=light
endif

au FileType ruby set tabstop=2
au FileType ruby set shiftwidth=2
au FileType ruby set softtabstop=2

let perl_extended_vars=1
let perl_include_pod=1
let perl_string_as_statement=1
let perl_sync_dist=1000

filetype indent on

highlight Search NONE ctermfg=lightred
autocmd InsertEnter * syn clear EOLWS | syn match EOLWS excludenl /\s\+\%#\@!$/
autocmd InsertLeave * syn clear EOLWS | syn match EOLWS excludenl /\s\+$/
hi EOLWS ctermbg=red

autocmd BufReadPost *
\  if line("'\"") > 0 && line("'\"") <= line("$") |
\    exe "normal g`\"" |
\  endif

if filereadable($HOME . '/.workvim/skeletons/module.pm')
    autocmd BufNewFile *.pm silent 0read ~/.workvim/skeletons/module.pm | call Modulify('::') | normal G5k
else
    autocmd BufNewFile *.pm silent 0read ~/.vim/skeletons/module.pm | call Modulify('::') | normal G5k
endif

if filereadable($HOME . '/.workvim/skeletons/perl.pl')
    autocmd BufNewFile *.pl silent 0read ~/.workvim/skeletons/perl.pl | normal G
else
    autocmd BufNewFile *.pl silent 0read ~/.vim/skeletons/perl.pl | normal G
endif

autocmd BufNewFile *.t silent 0read ~/.vim/skeletons/test.t | normal G
autocmd BufNewFile Makefile.PL silent undo | silent 0read ~/.vim/skeletons/Makefile.PL | normal gg

autocmd BufNewFile *.c  silent 0read ~/.vim/skeletons/c.c | normal 4j$

autocmd BufNewFile *.html  silent 0read ~/.vim/skeletons/page.html | normal 9j0

autocmd BufReadPost *.smc set bin | set noeol
au BufWritePost *.{sh,pl} silent exe "!chmod +x %"

autocmd FileType perl setlocal makeprg=$VIMRUNTIME/tools/efm_perl.pl\ -c\ %\ $*
autocmd FileType perl setlocal errorformat=%f:%l:%m
autocmd FileType perl setlocal keywordprg=perldoc\ -f

autocmd BufNewFile,BufRead *.reg set ft=perl
autocmd BufNewFile,BufRead *.run set ft=perl
autocmd BufNewFile,BufRead repl.rc set ft=perl
autocmd BufNewFile,BufRead *.scpt set ft=applescript
autocmd BufNewFile,BufRead *.repl.rc set ft=perl

autocmd BufNewFile,BufRead *.tt set ft=tt2html

if hostname() == 'dev1' || hostname() == 'jobs01'
    autocmd BufNewFile,BufRead silverback.conf set syntax=apache
    autocmd BufWritePost *.pl,*.pm,*.reg,*.run !perl -wcI/data/silverback/lib %
endif

inoremap <silent> <C-a> <ESC>u:set paste<CR>.:set nopaste<CR>gi

nmap Y y$

nnoremap \\ \
nmap \/ :nohl<CR>
nmap \n :set invnumber<CR>

nmap ds :%s/\s\+$//<CR>

autocmd FileType help nnoremap <buffer> <CR> <C-]>
autocmd FileType help nnoremap <buffer> <BS> <C-T>

nmap <Right> :bn<CR>
nmap <Left>  :bp<CR>
map <Leader>h i$html .= <<_STOP_;<CR><Esc>0i_STOP_<Esc>O

nmap <silent> gw "_yiw:s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<cr><c-o><c-l>:nohl<CR>

nmap n nzz
nmap N Nzz
nmap * *zz
nmap # #zz
nmap g* g*zz
nmap g# g#zz
nmap <C-u> <C-u>zz
nmap <C-d> <C-d>zz

au FileType tt2 imap [% [%  %]<Left><Left><Left>
au FileType tt2html imap [% [%  %]<Left><Left><Left>

function s:nopaste(visual)
    let nopaste_services = $NOPASTE_SERVICES
    if &filetype == 'tex'
        let $NOPASTE_SERVICES = "Mathbin ".$NOPASTE_SERVICES
    endif

    if a:visual
        silent exe "normal gv!nopaste -x\<CR>"
    else
        let pos = getpos('.')
        silent exe "normal gg!Gnopaste -x\<CR>"
    endif
    silent undo
    if a:visual
        normal gv
    else
        call setpos('.', pos)
    endif
    let $NOPASTE_SERVICES = nopaste_services
endfunction
"nmap <silent> <Leader>p :call <SID>nopaste(0)<CR>
xmap <silent> <Leader>p :<C-U>call <SID>nopaste(1)<CR>

fun Modulify(replace)
    silent :%s#Foo#\=expand("%")#
    silent :%s#\.pm##
    silent :%s#lib/##e
    silent :%s# /# #e
    silent :%s#/#\=a:replace#ge
endfun

au BufNewFile,BufReadPost * silent !mkdir -p $(dirname %)
au BufNewFile,BufReadPost *.asl set ft=ruby
au BufNewFile,BufReadPost *.t set ft=perl

function! PerlDoc()
    normal yy
    let l:this = @
    if match(l:this, '^ *\(use\|require\) ') >= 1
        exe ':5new'
        let l:this = substitute(l:this, '^ *\(use\|require\) *', "", "")
        let l:this = substitute(l:this, ";.*", "", "")
        let l:this = substitute(l:this, " .*", "", "")
        exe ':0r!perldoc -T ' . l:this . ' | uncolor.pl'
        exe ':0'
        exe ':echo "test"'
        exe ':set ft=man'
        return
    endif
    normal yiw
    exe ':new'
    exe ':resize'
    exe ':0r!perldoc -Tf ' . @
    exe ':0'
endfunction

map ,h :call PerlDoc()<C-M>:set nomod<C-M>

nmap H ^
vmap H ^
nmap L $
vmap L $

nmap M       :nohl<CR>:syntax sync fromstart<CR>
"nmap L       :bn<CR>
"nmap H       :bp<CR>
nmap -       A<Esc>

"nmap <Up>    :wa<CR>
"nmap <Down>  :wa<CR>
nmap <Left>  :bn<CR>
nmap <Right> :bp<CR>

nmap     gb       A {<CR>}<Esc>k
nmap     <CR>     o<Esc>
nmap     <F1>     <Esc>
inoremap <F1>     <Esc>
imap     <C-J>    <Esc>
nmap     <Leader>psql :!psql -1 -f %

if hostname() == 'jobs01'
    map <Leader>ar :!sudo /sbin/service httpd restart<CR>
elseif hostname() == 'dev1'
    map <Leader>ar :!sudo /sbin/service httpd restart<CR>
else
    map <Leader>ar :!sudo /etc/init.d/apache2 restart<CR>
endif

if hostname() == 'dev1'
    highlight Comment ctermfg=green
endif

function! TextEnableCodeSnip(filetype,start,end,textSnipHl) abort
  let ft=toupper(a:filetype)
  let group='textGroup'.ft
  if exists('b:current_syntax')
    let s:current_syntax=b:current_syntax
    " Remove current syntax definition, as some syntax files (e.g. cpp.vim)
    " do nothing if b:current_syntax is defined.
    unlet b:current_syntax
  endif
  execute 'syntax include @'.group.' syntax/'.a:filetype.'.vim'
  try
    execute 'syntax include @'.group.' after/syntax/'.a:filetype.'.vim'
  catch
  endtry
  if exists('s:current_syntax')
    let b:current_syntax=s:current_syntax
  else
    unlet b:current_syntax
  endif
  execute 'syntax region textSnip'.ft.'
  \ matchgroup='.a:textSnipHl.'
  \ start="'.a:start.'" end="'.a:end.'"
  \ contains=@'.group
endfunction

au BufNewFile,BufReadPost *.pl,*.pm,*.reg
            \ call TextEnableCodeSnip('sql', 'qq\[', '\]', 'String')

iabbrev to_jason   to_json
iabbrev from_jason from_json
iabbrev reponse    response
iabbrev shift shift
iabbrev shift shift


nnoremap - <Space>
nmap b :buffer!<Space>

autocmd FileType perl setlocal makeprg=$VIMRUNTIME/tools/efm_perl.pl\ -c\ %\ $*
autocmd FileType perl setlocal errorformat=%f:%l:%m
set backupskip=/tmp/*,/private/tmp/*"

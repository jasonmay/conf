use lib 'lib';

no warnings 'redefine';

use DateTime;
use List::Util qw(first max maxstr min minstr reduce shuffle sum);
use List::MoreUtils ':all';
use Scalar::Util qw(blessed weaken isweak tainted);
use Scalar::Defer qw(lazy defer force);
use File::Slurp qw(slurp);
use String::Util ':all';
use Term::ANSIColor;

# Silence complaints about redefining 'io'
BEGIN {
    no strict 'refs';
    delete ${__PACKAGE__.'::'}{io};
}
use IO::All;

*fold = \&reduce;

sub say { print @_, "\n" }

my @plugins = (
    'ReadLineHistory',            # history saved across sessions
    'Colors',                     # colorize return value and errors
    'FancyPrompt',                # provide an irb-like prompt
    'Refresh',                    # refresh before every eval
    'Interrupt',                  # improve handling of ^C
    'OutputCache',                # access previous results
    'Nopaste',                    # paste session with #nopaste
    'PPI',                        # PPI dumping of Perl code
    'MultiLine::PPI',             # allow multiple lines
    'LoadClass',                  # automatically load unloaded classes

    'Completion',
    'CompletionDriver::Keywords', # substr, while, etc
    'CompletionDriver::LexEnv',   # current environment
    'CompletionDriver::Globals',  # global variables
    'CompletionDriver::INC',      # loading new modules
    'CompletionDriver::Methods',  # class method completion
    'CompletionDriver::Turtles',  # turtle command completion
);

$_REPL->load_plugin($_) for @plugins;
$_REPL->fancy_prompt(sub { "\e[m\n> " } );
$_REPL->fancy_prompt(sub {
    my $self = shift;
    "\ca" . color('blue')  . "\cb" . $self->current_package
  . "\ca" . color('green') . "\cb" . '(0)'
  . "\ca" . color('reset') . "\cb" . '> '
} );
$_REPL->fancy_continuation_prompt(sub {
    my $self = shift;
    "\ca" . color('blue')   . "\cb" . $self->current_package
  . "\ca" . color('yellow') . "\cb" . '(' . $self->line_depth . ')'
  . "\ca" . color('reset')  . "\cb" . '> ' . (' ' x ($self->line_depth * 2))
});

sub fib {
    my $num = shift;
    return 0 if $num == 1;
    return 1 if $num == 2;
    return fib($num - 1) + fib($num - 2);
}
